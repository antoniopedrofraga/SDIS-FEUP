package channels;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ThreadLocalRandom;

import database.Storage;
import messages.Header;
import messages.Message;
import peers.Peer;

public class McChannel extends Channel {
	ArrayList<Message> storedReplies;
	boolean waitingReplies = false;


	public McChannel(String mcAddress, String mcPort) throws IOException {
		super(mcAddress, mcPort);
		this.storedReplies = new ArrayList<>();
	}
	
	private void handleGetChunk(Header header) throws InterruptedException, IOException {
		byte[] body = Storage.getChunkBody(header.getFileId(), header.getChunkNo());		
		Header replyHeader = new Header(Message.CHUNK, Peer.getServerId(),
				Peer.getServerId(), header.getFileId(), header.getChunkNo(), null);
		Message reply = new Message(Peer.getMcChannel().getSocket(), Peer.getMcChannel().getAddress(), replyHeader, body);
		int timeout = ThreadLocalRandom.current().nextInt(0, 400);
		Thread.sleep(timeout);
		new Thread(reply).start();
	}
	
	public void handleMessage(Header header, byte[] body) throws InterruptedException, IOException{
		switch (header.getMsgType()) {
		case Message.GETCHUNK:
			if (!Storage.chunkIsStored(header.getFileId(), Integer.parseInt(header.getChunkNo())))
				break;
			handleGetChunk(header);
		case Message.STORED:
			if (waitingReplies)
				storedReplies.add(new Message(header, body));
			break;
		}
	}

	
	public ArrayList<Message> getStoredReplies() {
		return storedReplies;
	}

	public void setWaitingReplies(boolean waitingReplies) {
		this.waitingReplies = waitingReplies;
	}
}
