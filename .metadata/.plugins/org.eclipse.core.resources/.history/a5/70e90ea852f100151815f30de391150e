package subprotocols;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import database.Database;
import exceptions.ArgsException;
import messages.Header;
import peers.Peer;
import utilities.Constants;

public class Backup extends Thread{
	private String fileName;
	private int replicationDeg;
	
	public Backup(String fileName, String replicationDeg) throws ArgsException {
		this.fileName = fileName;
		this.replicationDeg = Integer.parseInt(replicationDeg);
		if (this.replicationDeg > 9 && this.replicationDeg < 1)
			throw new ArgsException("ReplicationDeg must be a number between 1 and 9...");
	}
	
	public void run() {
		Path path = Paths.get(Constants.FILES_ROOT + fileName);
		try {
			byte[] data = Files.readAllBytes(path);
			sendChunks(data);
		} catch (IOException | InterruptedException e) {
			e.printStackTrace();
		}
	}

	private void sendChunks(byte[] data) throws InterruptedException {
		int waitingTime = Constants.DEFAULT_WAITING_TIME;
		int chunksNum = data.length / Constants.CHUNK_SIZE + 1;
		Header header = new Header(Constants.BACKUP, "1.0", Peer.getServerId(), fileName, "0", replicationDeg + "");
		for (int i = 0; i < chunksNum; i++) {
			byte[] chunk = getChunkData(i, header, data);
			ChunkBackup backupChunk = new ChunkBackup(header, chunk);
			int chunksSent = 0;
			while (chunksSent < Constants.MAX_CHUNK_RETRY) {
				System.out.println("Sending chunk number " + i + ", waiting " + waitingTime + "ms after that.");
				backupChunk.sendChunk();
				Thread.sleep(waitingTime);
				Thread thread = new Thread(backupChunk);
				thread.start();
				if (Peer.getDataBase().countConfirmedChunks(header) < replicationDeg) {
					chunksSent++;
				} else {
					break;
				}
			}
		}
	}

	private byte[] getChunkData(int i, Header header, byte[] data) {
		header.setChunkNo(i + "");
		int dataSize = Constants.CHUNK_SIZE - header.toString().getBytes().length;
		int lastIndex = (i + 1) * dataSize < data.length ? (i + 1) * dataSize : data.length;
		return Arrays.copyOfRange(data, i * Constants.CHUNK_SIZE, lastIndex);
	}
}
