package channels;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import messages.Header;
import messages.Message;
import peers.Peer;
import utilities.Constants;

public class MdbChannel extends Channel{
	
	public MdbChannel(String mdbAddress, String mdbPort) throws IOException {
		super(mdbAddress, mdbPort);
		this.thread = new MdbThread();
	}
	
	public void listen() {
		this.thread.start();
	}
	
	public void handlePutChunk(String[] splittedHeader, byte[] body) throws InterruptedException {
		
		//save chunk
		System.out.println("That PUTCHUNK had " + body.length + " bytes of data.");
		Long chunkNo = Long.parseLong(splittedHeader[Constants.CHUNK_NO]);
		try {
			Peer.getStorage().saveChunk(splittedHeader[Constants.FILE_ID], chunkNo, body);
		} catch (IOException e) {
			System.out.println("Could not save the chunk number " + splittedHeader[Constants.CHUNK_NO] + "from file " + splittedHeader[Constants.FILE_ID]);
			return;
		}
		System.out.println("Chunk number " + splittedHeader[Constants.CHUNK_NO] + " from file " + splittedHeader[Constants.FILE_ID] + " was saved! Replying...");
		
		//reply
		Header header = new Header(Constants.STORED, splittedHeader[Constants.VERSION],
				Peer.getServerId(), splittedHeader[Constants.FILE_ID], splittedHeader[Constants.CHUNK_NO], null);
		Message reply = new Message(Peer.getMcChannel().getSocket(), Peer.getMcChannel().getAddress(), header, null);
		int timeout = ThreadLocalRandom.current().nextInt(0, 400);
		Thread.sleep(timeout);
		new Thread(reply).start();
	}
	
	public class MdbThread extends Thread {
		public void run() {
			while(true) {
				System.out.println("Listening the MDB channel...");
				try {
					socket.joinGroup(address);
					// separate data
					String data = Peer.rcvMultiCastData(socket, address);
					Message message = Message.getMessageFromData(data);
					Header header = message.getHeader();
					byte[] body = message.getBody();
					
					//analising data
					if(!Peer.getServerId().equals(header.getSenderId())) {
						switch (header.getMsgType()) {
						case Constants.PUTCHUNK:
							System.out.println("Received a PUTCHUNK message, will handle it...");
							handlePutChunk(header, body);
							break;
						default:
							System.out.println("Ignoring message from type " + header.getMsgType());
							break;
						}
					}
					socket.leaveGroup(address);
				} catch (IOException | InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
