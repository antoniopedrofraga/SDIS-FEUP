package utilities;

import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

import data.ChunkInfo;

public class SpaceSolution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number 
     *          and the index of the last number
     */
    public ArrayList<Integer> subarraySumClosest(ArrayList<ChunkInfo> chunks, int num) {
        // write your code here
        ArrayList<Integer> res = new ArrayList<Integer>();
        if (chunks == null || chunks.size() == 0) {
            return res;
        }
        TreeMap<Long, Integer> map = new TreeMap<Long, Integer>();
        long sum = num;
        long minDiff = (long)Integer.MAX_VALUE + 1;
        res.add(0);
        res.add(0);
        for (int i = 0; i < chunks.size(); i++) {
            sum += chunks.get(i).getChunkSize();
            // . . . [floorEntry] [sum] [ceilingEntry] . . .
            Map.Entry floorEntry = map.floorEntry(sum);
            Map.Entry ceilingEntry = map.ceilingEntry(sum);
            int curDiff = 0;
            if (floorEntry != null || ceilingEntry != null) {
                //ceiling
                if (floorEntry == null || (ceilingEntry != null && Math.abs((long)floorEntry.getKey() - sum) > Math.abs((long)ceilingEntry.getKey() - sum))) {
                    if (Math.abs((long)ceilingEntry.getKey() - sum) < minDiff) {
                        res.set(0, (int)ceilingEntry.getValue() + 1);
                        res.set(1, i);
                    }
                } else { //floor
                    if (Math.abs((long)floorEntry.getKey() - sum) < minDiff) {
                        res.set(0, (int)floorEntry.getValue() + 1);
                        res.set(1, i);
                        minDiff = Math.abs((long)floorEntry.getKey() - sum);
                    }
                }
            }
            map.put(sum, i);
        }           
        return res;
    }
}
